# Документация архитектуры процессоров

Содержание:

- [1. Файловая структура](#файловая-структура)
- [2. Запуск процессора](#запуск-процессора)
- [3. Стиль кода процессора](#стиль-кода-процессора)

# Файловая структура

```shell
.
└── ritm3
    ├── __init__.py
    ├── processors # папка где теперь будут храниться .py файлы процессоров
    │   ├── processor_1.py
    │   ├── processor_2.py
    │   ├── processor_2.py
    │   ├── ...
    ├── processors.py # старый файл с процессорами будет удален
    ├── processors_watch.py # логика контроля конвеера процессоров
    ├── the_tyre.py # handle_workflow API
    └── ...
```

Теперь каждый процессор будет представлять отдельный `.py` файл а не `python` функцию.
Они будут храниться в папке `ritm3/processors`. Таким образом все процессоры выполненые
ввиде `python` функций в файле `processors.py` надо будет перенести в формат отдельных
файлов, а сам файл `processors.py` нужно будет удалить за ненадобностью.

`the_tyre.py` так же как и раньше будет содержать логику `handle_worflow` API. Однако
теперь он не будет выполнять весь конвеер процессоров. А лишь будет обрабатывать
запрос и перенаправлять его на выполнение в виде отдельного `python` процесса
`processors_watch.py`.

`processors_watch.py` будет соответсвенно отвечать за исполнение каждого процессора
в нужном порядке. А так же будет следить за их статусом. *Данный файл должен содержать
логику `web socket` соединения с фронтом, чтобы давать статус о процессах в реальном времени*.

**Каждый процессор в виде input'а (*первый параметр*) принимать файловый путь. Потому что выходные данные предыдущего процессора будут сохранены
в некоторый файл.**

# Запуск процессора

Так как каждый процессор теперь является отдельным файлом, то стоит рассматривать его как отдельную программу.
Например обычно `python` программы запускаются следующим образом:

```shell
python hello.py
```

В нашем же случаее у нас еще будут входные параметры для каждого процессора, поэтому это будет
выглядеть следующим образом:

```shell
python processor.py par_1 par_2 par_3 ...
```

В ветке есть пример, процессора в новом стиле в виде файла `processors/https_response.py`, который
овечает за обработку http POST и GET запросов. Пример вызова:

```shell
$ python https_request.py 'GET' 'https://catfact.ninja/fact' # строка shell команды
{"fact":"Cats have the largest eyes of any mammal.","length":41} # STDOUT ответ
```

В данном случае `GET` и `https://catfact.ninja/fact` являются `par_1` и `par_2` соответсвенно.
Порядок и тип параметров важен только для конкретного процессора, т.е. нет никакого
шаблона по входным параметрам. **Однако первым параметром `par_1` должен являться input файловый путь**.

Далее видно, что процессор выдает свой `output` в STDOUT (*просто пишет в консоль*).

Как выглядит запуск этого процессора внутри `processors_watch.py`:

```python
cmd = ['python', 'processors/https_request.py', 'GET', 'https://catfact.ninja/fact']

output = open('processors/output.txt', mode='w', encoding='utf8')

p = subprocess.Popen(cmd,
                     stdout=output,
                     stderr=subprocess.STDOUT)
```

В данном случае видно, что STDOUT программы перенаправляется в некоторый файл.

## Лайхак по разработке процессора

Так как каждый процессор является отдельной программой, то его можно тестировать
отдельно от `container-back` и от других процессоров. Но конечно каждый процессор тогда
должен соответсовать определенным стандартам (о них будет сказано дальше).

Появляется следующий вопрос: как я могу разрабатывать свой процессор если он первым параметром 
принимает `input` аргумент.

Ответ: Можно создать данный файл вручную или получить выходные данные из другого процессора
следующим образом:
```shell
$ python <proc_name>.py <parameters> > /path/to/output.txt
```

# Стиль кода процессора

Так как каждый процессор ведет себя как отдельная программа, то
нужно подключить стандартную библиотеку `sys`:

```python
import sys
```

Далее чтобы получить, параметры из командной строки нужно использовать
`sys.argv`:

```python
parameter = sys.argv[<parameter_index>]
```

Стоит помнить, что 0 аргумент это имя `python файла`. Например возьмем следующую программу:
```python
import sys

par_0 = sys.argv[0]
par_1 = sys.argv[1]
par_1 = sys.argv[2]

print(par_0)
print(par_1)
print(par_2)
```

Она даст следующий результат:
```shell
$ python test.py 123 "string"
test.py
123
string
```

Далее `processors_watch.py` полагается на `exit code` программы (*это такой номер, который программа
сообщает в среду по завершению*). `0` - программа завершилась успешно, `1` - произошла ошибка. Пример:
```python
import sys

...

if is_error():
    sys.exit(1) # stop program with error code -1

sys.exit(0) # stop program with success code - 0
```
