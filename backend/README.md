# Документация ritm3-the-tyre

1. [Архитектура веб-приложения](#архитектура-веб-приложения)\
1.1. [Выгрузка данных](#выгрузка-данных)\
1.2. [Обработка данных](#обработка-данных)\
1.3. [Сохранение данных](#сохранение-данных)\
1.4. [Процессор](#процессор)\
1.5. [Конвейер процессоров](#конвейер-процессоров)
2. [Структура контейнеров](#структура-контейнеров)
3. [Основные Docker команды](#основные-docker-команды)
4. [container-front](#container-front)
5. [container-back](#container-back)\
5.1. [auth.py](#authpy)\
5.2. [support_functions.py](#support_functionspy)
6. [container-db](#container-db)
7. [Список процессоров](#список-процессоров)\
7.1. [http_request.py](#http_requestpy)\
7.2. [save_to_db.py](#save_to_dbpy)\
7.3. [dummy_parser.py](#dummy_parserpy)\
7.4. [json_parser.py](#json_parserpy)
    - [ООП архитектура процессора](#ооп-архитектура-процессора)
    - [Инструкция по использованию](#инструкция-по-использованию)
    - [Название переменной](#название-переменной)
    - [Запрос](#запрос)
    - [Название функции](#название-функции)
    - [Список функций](#список-функций)
    - [Техническая реализация](#техническая-реализация)
8. [Взаимодествие фронтенда с бекенд API](#взаимодествие-фронтенда-с-бекенд-api)
9. [API reference](#api-reference)\
9.1. [/api/login](#apilogin)\
9.2. [/api/register](#apiregister)\
9.3. [/api/auth_test](#apiauth_test)\
9.4. [/api/handle-workflow](#apihandle-workflow)\
9.5. [/api/get-processors-list](#apiget-processors-list)\
9.6. [/api/get-workflow-status](#apiget-workflow-status)
10. [Фронтенд скрипты](#фронтенд-скрипты)\
10.1 [registration.js](#registrationjs)\
10.2 [validator.js](#validatorjs)\
10.3. [get-login-data.js](#get-login-datajs)
11. [Структурная идея верстки](#структурная-идея-верстки)\
11.1. [Именование классов](#именование-классов)\
11.2. [Технические классы](#технические-классы)
12. [Файловая архитектура frontend](#файловая-архитектура-frontend)
13. [Тестирование](#тестирование)

## Архитектура веб-приложения

Основная цель приложения - обработка данных со сторонних API для последующей манипуляции с ними. Приложение поддерживает функционал [выгрузки данных](#выгрузка-данных), [их обработки](#обработка-данных) и [сохранения](#сохранение-данных) либо в базу данных, либо в файл. Каждая функция представлена в виде отдельного блока - [процессора](#процессор). Процессоры можно выстраивать в любом порядке для получения желаемого результата с помощью [конвейера процессоров](#конвйеер-процессоров). Приложение работает с помощью [запросов](#api-reference) между бекендом, базой данных и фронтендом, где каждый элемент представлен в виде [отдельного Docker контейнера](#структура-контейнеров).

### Выгрузка данных

На данный момент есть только получение данных из http запроса к стороннему API. Возможны GET и POST
(*еще не работает*) запросы. Полученый ответ далее доступен для обработки другими процессорами. Планируется
так же получение данных из базы данных и из csv, json файлов.

### Обработка данных

Разработан аналог языка JOLT, который позволяет формировать входные данные в формате JSON в новый JSON файл,
в котором данные будут храниться в соответсвии с запросом пользователя. (*пока не работает в конвейере, только
отдельно*)

Планируется html парсер, который будет работать на python скрипте предоставленным пользователем. Пока еще
не был реализован.

### Сохранение данных

Представляет с собой функционал сохранения данных либо в базу данных, либо в файл. Состоит из двух отдельных процессоров: `save_to_db` и `save_to_file` (*в разработке*). 

### Процессор

Отдельный `.py` файл. Выполняет изолированную задачу. Работает по принципу: "Одно действие - один процессор". Параметры
для процессора генерируются на фронтенде через различные HTML формы и JS код. Далее список параметров
передается на бекенд, где дальше и обрабатывается результат. Все процессоры хранятся в папке `container-back/src/processors`. Для каждого процессора написана своя статья в документации ([список процессоров](#список-процессоров)).

### Конвейер процессоров

Для составления логического порядка процессоров представлен так называемый конвейер процессоров. Основная его задача - принимать данные из предыдущего [процессора](#процессор) для обработки его в новом процессоре. 

Например, для получения данных из API `https://catfact.ninja/fact` и обработки результата для сохранения в базу данных необходимо построить следующее дерево процессоров:

1. Сделать http запрос к данному API `http_request.py`
2. Произвести парсинг ответных данных `dummy_parser.py` (*jolt parser еще не был протестирован*)
3. Сохранить их в базу данных. `save_to_db.py`

Для более детального ознакомления рекомендуется прочитать [техническую реализацию конвейера процессоров](#техническая-реализация-конвейера-процессоров).

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## Структура контейнеров

Основная информация о структуре контейнеров храниться в файле `docker-compose.yml`.

Есть 3 контейнера:
- `container-front` - фронтенд составляющая
(веб-приложение, отрисовка GUI, авторизация пользователя через back-end API)
- `container-back` - бекенд составляющая (предоставление бекенд API, авторизация
пользователя, взаимодействие с базой данных)
- `container-bd` - база данных PostgreSQL

Фронтенд и бэкенд контейнерам соответсвуют папки `container-front` и `container-back`, в которых
находится код, используемый данными контейнерами.

В `container-back` есть `Dockerfile`. Этот файл содержит инструкции для более детальной настройки контейнера.

`.env` файл содержит переменные среды, которые доступны в контейнерах `container-back`
и `container-bd`.

*В будующем будет разделение на `docker-compose-dev.yml` и `docker-compose-prod.yml`
для разработки и продакшена соответственно (на данный момент все настройки расчитаны
на разрабоку)*

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## Основные Docker команды

Каждому контейнеру присвоено нескольно профилей, что позволяет запускать те контейнеры,
которые нужны в данный момент.

- frontend: `container-front`
- backend: `container-back`
- backend-api: `container-back`
- backend-db: `container-db`
- all: `container-front` `container-back` `container-db`

Запустить все 3 контейнера:
(для некоторых систем команда может быть `docker-compose`, а не `docker compose`)
```bash
docker compose --profile all up --build
```

Запустить `container-front` и `container-back`:
```bash
docker compose --profile frontend --profile backend-api up --build
```

Опция `-d` позволяет запустить конейнеры в фоновом режиме.
Запустить `container-back` в фоновом режиме:
```bash
docker compose --profile backend up --build -d
```

Отобразить контейнеры, которые запущенны сейчас:
```bash
docker ps
```

Остановить контейнер `<container_name>`:
```bash
docker rm -f <container_name>
```

Зайти в `bash` на уже запущенном контейнере `<container_name>`:
```bash
docker exec -it <container_name> bash
```

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## container-front

- HTML/CSS/JS
- nginx - для обработки http-запросов

Внешний порт - 8080 (*во время разработки*)

В качестве http-сервера используется `nginx`. Эта технология позволяет отображать статические файлы, соответсвующие http-запросу. Также он является обратным прокси, что позволяет часть запросов перенаправлять на другой сервер. Здесь наиболее важно, что с помощью nginx можно делать запросы между фронтендом и бекендом. В качестве языка для взаимодействия контейнеров используется JSON.

`nginx.conf` содержит конфигурацию для обработки http-запросов.

Пример работы с nginx:

- / -> файлы в папке static.

Здесь nginx является веб-сервером и отображает файлы по запросу (файлы в папке 
`container-front/static`). Допустим, чтобы открыть страницу `static/main-page.html` в веб-браузере, необходимо сделать запрос `http://localhost:8080/main-page.html` или, если страница находиться в папке, как `static/some/directory/page.html`, тогда запрос будет `http://localhost:8080/some/directory/page.html`.

- /api/ -> container-back:5000/api/<...>

Здесь nginx является обратным прокси и все запросы по пути `http://localhost:8080/api/<some-request>` перенаправляются в бекенд контейнер `http://container-back:5000/api/<some-request>`. Таким образом пример JS запроса будет выглядеть так.
```js
fetch("/api/<some-request>", ...).then...
```
Более подробно про JSзапросы можно почитать [в данной статье (англ.)](https://howtocreateapps.com/fetch-and-display-json-html-javascript/).

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## container-back

- Python 3
- [Flask](https://flask.palletsprojects.com) - Web Framework
- [psycopg2](https://www.psycopg.org/docs/) - модуль для взаимодействия с Postgres базой данных
- [PyJWT](https://pyjwt.readthedocs.io/en/latest/) - модуль для работы с JWT токенами

Переменные среды - из файла `.env`

Структура (папка `src`):
- `ritm3` - папка для бэкенд API, реализованного Flask приложением
- `processors_watch.py` - контроль конвейера процессоров
- `processors` - папка с файлами процессоров

Переменные приложения задаются в файле `__init__.py`:
```python
app.config.from_mapping(
        SECRET_KEY=os.environ['FLASK_SECRET_KEY'],
        DB_HOST=os.environ['DB_HOST'],
		...
    )
# os.environ['VAR_NAME'] - возвращает значение переменной среды VAR_NAME
```

Далее их можно использовать следующим образом:
```python
host=current_app.config["DB_HOST"]
```

Список документации к файлам:
- [auth.py](#authpy)
- [support_funcitions.py](#support_functionspy)

### auth.py
Модуль для хранения функций аутентификации пользователя.

- **validate_token(token)**

*token* - потенциальный JWT токен\
Тип - int

Используется для проверки токена на подлинность. 

Возвращает\
`auth.TOKEN_INVALID`, если токен неверный;\
`auth.TOKEN_EXPIRED`, если токен вышел из срока годности;\
`auth.TOKEN_VALID`, если токен корректный.

### support_functions.py
Модуль для хранения вспомогательных функций.

- **fetchone_by_pattern_attribute_value(table_name, query)**

*table_name* - имя таблицы, откуда нужно взять данные\
*query* - SQL запрос для получения данных из таблицы\
Тип - dict

Используется для получения данных из таблицы по шаблону "атрибут-значение" по заданному запросу (query). Является расширением функции fetchone() из библиотеки psycopg2, поэтому может выдать только один кортеж, значения которого удовлетворяют условиям запроса. Если такого кортежа нет, то функция возвращает None.

Пример:
```python
table_name = "users_list"
query = f"SELECT * FROM users_list WHERE username = 'admin';"
user = fetchone_by_pattern_attribute_value(table_name, query)

Результат: ["id": 1, "username": "admin", "password": "admin"]
```

- **get_page_html_markup(url)**

*url* - ссылка, откуда нужно выгрузить HTML разметку\
Тип - str (формат: utf-8)

Используется для получения HTML разметки веб-страницы по данной ссылки. Работает с HTTP и HTTPS запросами. Для реализации использовались библиотеки pycurl, выгрузка HTML разметки, и certifi, для работы с HTTPS. Принимает данные вне зависимости от языка. 

- **check_json_fields_existance(fields_list, json_dict)**

*fields_list* - список, полей, которые должен содержать JSON словарь\
*json_dict* - JSON словарь\
Тип - bool

Используется для проверки JSON словаря на содержание всех нужных полей. Если
словарь содержит все поля из списка, то возращается `True`, в противном случаее - `False`.

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## container-db

- [Postgres](https://www.postgresql.org/) - СУБД

Переменные среды - из файла `.env`

Подключение к интерфесу СУБД (сначала зайти в `bash`):
```bash
psql -U "$POSTGRES_USER" "$POSTGRES_DB"
```

База данных создается в корне проекта в папке `data`, поэтому ее нужно создать перед запуском.

Чтобы произвести инициализацию базы данных, необходимо после создания проекта зайти в `bash` на контейнере
`container-back` и прописать следующую команду:

```bash
flask init-db
```
(конечно, `container-db` должен быть запушен в это время)

Если нужно очисть базу данных, то самый простой метод в таком случаее это просто удалить
и заново создать папку `data`. Соответственно, придется после этого сделать инициализацию.

[Обратно к оглавлению](#документация-ritm3-the-tyre)  

## Список процессоров

- [http_request.py](#http_requestpy)
- [save_to_db.py](#save_to_db.py)
- [dummy_parser.py](#dymmy_parserpy)
- [json_parser.py](#json_parserpy)

[Обратно к оглавлению](#документация-ritm3-the-tyre) 

### http_request.py

Основная задача - отправлять http GET и POST запросы и передавать данные\
Статус: частично готов (*работает только GET*)\
Аргументы (всего 4):
- url
- METHOD (*GET или POST*)
- header (*нужен для POST, пустой для GET*)
- date (*нужен для POST, пустой для GET*)

Процессор может стоять только в начале, так как не имеет агрумента ввиде файла с входными данными.

Выходные данные просто представляют собой результат запроса.

[Обратно к списку процессоров](#список-процессоров) 

### save_to_db.py

Основная задача - сохранение данных в базу данных\
Статус: готов\
Аргументы (всего 2):
- **input_file_path** (**автоматический**: не считается аргументом; данные предыдущего процессора)
- connection_str - `"name= password= dbname= host= port= "`
- table_name (*таблица куда вставлять данные*)

Таблица должна существовать и содержать нужные поля. Сам процессор ничего не создает.
*На данный момент в базе данных есть только таблица cat_facts*.

Процессор пока не имеет никаких выходных данных, он "молча" записывает указанные данные в таблицу.

Пример входных данных:
```json
{
    "col1_name": <value>,
    "col2_name": <value>,
    ...
}
```

[Обратно к списку процессоров](#список-процессоров) 

### dummy_parser.py

Основная задача - обработка данных сайта [https://catfact.ninja/fact](https://catfact.ninja/fact)\
Статус: готов\
Аргументы (всего 0):
- **input_file_path** (**автоматический** не считается аргументом, данные предыдущего процессора)

Не является "настоящим процессором". Как было сказно в "Основной задаче", парсит лишь данные с определенного сайта,
который содержит факты с котами. Он был создан времмено для того, чтобы можно было
протестировать работоспособность конвейера процессоров, пока `json_parser.py` еще не работает полноценно.

[Обратно к списку процессоров](#список-процессоров) 

### json_parser.py

Рабочее название - обработчик данных.\
Основная задача - обрабатывать JSON данные на основе собственного набора команд.\
Статус: находится в разработке.

Идейным вдохновителем для процессора являлась библиотека Jolt, цель которой - изменение существующего JSON файла с помощью своего собственного языка. Однако она была слишком сложной для изучения из-за своего особенного синтаксиса. В связи с этим был разработан обработчик данных, который способен выполнять функционал Jolt, но при этом использует наработки из объектно-ориентированного программирования для простоты использования.

- [ООП архитектура процессора](#ооп-архитектура-процессора)
- [Инструкция по использованию](#инструкция-по-использованию)
- [Название переменной](#название-переменной)
- [Запрос](#запрос)
- [Название функции](#название-функции)
- [Список функций](#список-функций)
- [Техническая реализация](#техническая-реализация)

[Обратно к списку процессоров](#список-процессоров) 

#### ООП архитектура процессора

Внутренняя реализация построена на принципе ООП, поэтому при использовании любых функций нужно обращаться с ними, как с объектами класса. 

Обязательным аргументом при создании объекта класса является переменная `structure`, которая показывает, с каким именно JSON объектом происходит работа. Тип переменной `structure` может быть только словарь! При любых изменениях переменная `structure` автоматически обновляется.

В дальнейшем будем использовать атрибут `Parser(structure)`, чтобы подчеркнуть наличие ООП в данном процессоре.

Пример корректного создания объекта класса:
```python
# тип structure - dict
structure = {
    "country": "the RF",
}

my_parser = Parser(structure)
```

[Обратно к json_parser.py](#json_parserpy)

#### Инструкция по использованию

Фундамент процессора построен на идеи, что при помощи определенного набора запросов и переменных пользователь может изменить существующий JSON файл так, как ему нужно. Код запросов и переменных пишется в специальном окне внутри пользовательского интерфейса процессора. При этом можно посмотреть JSON файл как ДО его изменения, так и предварительно посмотреть результат ПОСЛЕ его изменения.

Например, есть следующий JSON ответ с API
```json
{
    "Russian Cities": [
        {
            "ID City": 78,
            "City Name": "Saint Petersburg"
        },
        {
            "ID City": 77,
            "City Name": "Moscow",
        }
    ]
}
```

Мы хотим получить только номера городов. Для этого вводим специальную команду
```python
parsed_json = Parser(structure).save(['Russian Cities[].ID City'])
```

В итоге получаем следующий результат
```json
{
    "Russian Cities": [
        {
            "ID City": 78,
        },
        {
            "ID City": 77,
        }
    ]
}
```

Заметим, что в команде был использован специальный синтаксис. Дадим описание для каждой его части:\
`parsed_json` - название переменной;\
`save` - название функции;\
`'Russian Cities[].ID City'` - запрос.

Представим для каждого пункта подробный комментарий.

[Обратно к json_parser.py](#json_parserpy)

#### Название переменной

Используется по аналогии переменных в Python3. Для вывода результата работы процессора используется переменная с именем `result`.

Пример:
```python
command1 = Parser(structure).fetch("data[0]")
command2 = Parser(structure).fetch("key")

result = command1 + command2

Результат: сумма от сложения комманд fetch("data[0]") и fetch("key").
```

[Обратно к json_parser.py](#json_parserpy)

#### Запрос

Используется для навигации JSON файлу. Так как JSON может содержать в себе как списки, так и словари с глубоким уровнем вложенности, то был разработан специальный синтаксис для навигации внутри JSON файла, который сформулирован в виде следующих правил.

Правила составления запросов:
1. Чтобы перейти на объект с определенным уровнем вложенности, необходимо с помощью разделительных точек составить путь до желаемого объекта.

Пример:

Есть JSON файл со следующей вложенностью
```json
{
    "country":{
        "Russia": {
            "traffic rating": 0.6
        },
    }
}
```

Тогда для получения объекта `traffic rating` нужно выполнить следующий запрос:
```python
country.Russia.traffic rating

# Результат: 0.6
```
где\
`country`, `Russia`, `traffic rating` - объекты, которые содержат путь к `traffic rating`,\
`.` - разделительная точка к данному объекту.

2. Если внутри пути к объекту есть списки, то в таком случае название объекта должно заканчиваться с помощью квадратных скобок [].

Пример:

Есть JSON файл со следующей вложенностью
```json
{
    "countries": [
        {
            "Russia": {
                "traffic rating": 0.6,
                "public transport rating": 0.5
            },
        }
        {    
            "the US": {
                "traffic rating": 0.4,
                "public transport rating": 0.3
            }
        }
    ]
}
```
Тогда для получения объекта `traffic rating` внутри объекта `Russia` нужно выполнить следующий запрос:
```python
countries[].Russia.traffic rating

# Результат: 0.6
``` 

Заметим, что объект `countries[]` был написаны с квадратными скобками на конце, так как они представляют собой объект типа список, в то время как `Russia` и `traffic rating` были записаны без квадратных скобок, потому что они списком не являются.

[Обратно к json_parser.py](#json_parserpy)

#### Название функции

Функции - набор заранее подготовленных команд, по которым можно выполнить то или иное действие для обработки JSON файла.

[Обратно к json_parser.py](#json_parserpy)

#### Список функций

**Внимание!** Данный процессор построен по принципу ООП, поэтому при вызове любой функции нужно либо напрямую обращаться к классу `Parser`
```python
Parser(structure)
```
либо создать отдельную переменную, которая будет являться объектом данного класса
```python
mp = Parser(structure) # mp - сокращение от 'my_parser'
```

- [save(queries_list)](#savequeries_list)
- [fetch(query)](#fetchquery)
- [attach(existent_structure, new_value)](#attachexistent_structure-new_value)
- [change(query, new_value)](#changequery-new_value)
- [get_current_structure()](#get_current_structure)

[Обратно к json_parser.py](#json_parserpy)

- ##### save(queries_list)

*queries_list* - словарь запросов\
Результат: None

По заданному набору запросов сохраняет только требуемые поля из JSON файла с сохранением значения объектов. Про то, как составлять запросы, можно почитать с статье ["Запрос"](#запрос) выше.

Пример:

Есть исходный JSON файл
```json
{
    "countries": [
        {
            "Germany": {
                "traffic rating": 0.9,
                "public transport rating": 0.8
            },
            "the UK": {
                "traffic rating": 0.8,
                "public transport rating": 0.8
            }
        }
    ]
}
```

Мы хотим сохранить только поле `traffic rating` у объекта `Germany` с родителем `countries` - далее используем обозначение `countries` > `Germany` - и все поля у `countries` > `the UK`. Тогда мы вводим следующий запрос
```python
result = Parser(structure).save([
	'countries[].Germany.traffic rating',
	'countires[].the UK'
])
```

В итоге будет получен следующий результат:
```json
{
    "countries": [
        {
            "Germany": {
                "traffic rating": 0.9,
            },
            "the UK": {
                "traffic rating": 0.8,
                "public transport rating": 0.8
            }
        }
    ]
}
```

Заметим, что в самом запросе мы сначала написали полное название для требуемого объекта: `'countries[].Germany.traffic rating'` - а затем только его часть: `'countires[].the UK'`. Это говорит о том, что в первом случае мы просим команду выдать только объект `traffic rating`, у которого родителем является `Germany`, у которого, в свою очередь родителем является список `countries`. Во втором же случае мы говорим, что мы хотим получить все дочерние объекты у объекта `the UK`, у которого родителем является список `countries`.

[Обратно к списку функций](#список-функций)

- ##### fetch(query)

*query* - запрос\
Результат: запрашиваемый элемент (тип - зависит от элемента)

По заданному запросу сохраняет выдает значение определенного объекта JSON. Если в тексте запроса присутствуют списки, обязательно нужно указать индекс желаемого элемента списка (подробнее смотрите в примере ниже).

Пример:

Есть исходный JSON файл
```json
{
    "countries": [
        {
            "name": "Germany",
            "traffic rating": 0.9,
            "public transport rating": 0.8
        },
        {
            "name": "the UK"
            "traffic rating": 0.8,
            "public transport rating": 0.8
        }
    ]
}
```

Мы хотим получить значение объекта `traffic rating` на нулевой позиции списка `countires`. Для этого мы используем команду
```python
result = Parser(structure).fetch('countries[0].traffic rating')
```

В итоге будет получен следующий результат:
```json
0.9
```

Заметим, что здесь мы в `countries` использовали не только квадратные скобки `[]`, но также указали и индекс желаемого элемента. Если бы таковой не был указан, то команда не смогла бы понять, какой именно объект нам нужен, и выдала бы ошибку.

[Обратно к списку функций](#список-функций)

- ##### attach(existent_structure, new_value)

*existent_structure* - код уже существующей структуры\
*new_value* - значение, которое необходимо добавить\
Результат: None

Добавляет в существующую структуру `existent_structure` новое значение `new_value`. Вся структура делится на два типа: существующую и новую.

Например, пользователь хочет сложить существующую структуру с новым значением
```python
new_value = {
    "code": None,
}
```
и в итоге получить
```python
structure = {
    "country-greeting": [
        {
            "country": "Russia",
            "greeting": "Привет",
            "code": None
        },
        {
            "country": "the UK",
            "greeting": "Hi"
        }
    ]
}
```

Для этого ему необходимо написать команду
```python
existent_structure = "country-greeting[0]"
result = Parser(structure).attach(existent_structure, new_value)
```

[Обратно к списку функций](#список-функций)

- ##### change(query, new_value)

*query* - запрос, по которому нужно изменить значение\
*new_value* - новое значение, которое должно заменить старое значение по данному запросу\
Результат: None

Изменяет по данному запросу `query` старое значение на новое - `new_value`. 

Пример:
Пусть есть следующий словарь:
```python
{
    'a': {
        'b': {
            'c': 3,
            'd': 4
        }
    }
}
```
И мы хотим изменить значение "c" с путем "a.b.c" из "3" на "123". Для этого пишем следующую команду:
```python
query = 'a.b.c'
new_value = 123

Parser(structure).change(query, new_value)
```
В итоге получим следующую структуру:
```python
{
    'a': {
        'b': {
            'c': 123,
            'd': 4
        }
    }
}
```

[Обратно к списку функций](#список-функций)

- ##### get_current_structure()
Результат: текущее состояние обрабатываемого JSON словаря (тип - dict)

Возвращает текущее состояние обрабатываемого JSON словаря.

Пример:
Есть следующий словарь:
```python
{
    'a': 5,
    'b': 6
}
```
В результате некоторых изменений словарь изменился
```python
{
    'a': 23,
    'b': 34,
    'c': 45
}
```
Пользователь выполняет следующую команду:
```python
Parser(structure).get_current_structure()
```
И получает результат
```python
{
    'a': 23,
    'b': 34,
    'c': 45
}
```

[Обратно к списку функций](#список-функций)

#### Техническая реализация

Так как в реализации процессора есть много комплексных элементов с высоким уровнем абстрации, то было принято решение написать подробную документацию по основным функциям данного процессора, чтобы облегчить дальнейшее понимание программного кода. Остальные же функции, как правило, выполняют зачастую вспомогательную роль и не содержат в себе сложных абстракций.Здесь будет дан комментарий по каждой важной функции с целью объясненяю существующей в ней идей. Рекомендуется при прочтении иметь доступ к исходному коду.

- [fetch(query) - реализация](#fetchquery-реализация)
- [add(structure, existent_structure, new_value) - реализация](#addstructure-existent_structure-new_value-реализация)
- [save(queries_list) - реализация](#savequeries_list-реализация)
- [fill_structure() - реализация](#fill_structure-реализация)

[Обратно к json_parser.py](#json_parserpy)

##### Список функций

- ##### fetch(query) - реализация

По заданному запросу `query` выделяет список ключей в переменную `keys_list`. 

Например, если `query` выглядел бы следующим образом:
```python
query = 'cities[].Name'
``` 
то результат переменной `keys_list` был бы следующим:
```python
keys_list = ['cities[]', 'Name']
```

Далее с помощью цикла проходит все ключи. Если ключ является списком - например, `countries[21]` - тогда программа выделяет отдельно ключ `countires` и индекс `21`. Если нет, то продолжает работу до тех пор, пока функция не дойдет до последнего ключа из `keys_list` и не получит его значение. Как только будет получено значение, программа выдаст его в качестве результата работа функции.

[Обратно к технической реализации](#техническая-реализация)

- ##### add(structure, existent_structure, new_value) - реализация

Внимание! Данная функция очень похожа на функцию `attach`, однако у них совершенно разные обертки, потому что `add` используется как внутренняя реализация функции `attach`. Другими словами, на языке ООП: `add` - это приватная функция, которая занимается реализацией публичной функции `attach`.

Добавляет в существующую структуру `existent_structure` новое значение `new_value`. Вся структура делится на два типа: существующую и новую.

Например, пользователь хочет сложить существующую структуру
```json
{
    "country-greeting": [
        {
            "country": "Russia",
            "greeting": "Привет"
        },
        {
            "country": "the UK",
            "greeting": "Hi"
        }
    ]
}
```
с новым значением
```json
{
    "code": null,
}
```
и в итоге получить
```json
{
    "country-greeting": [
        {
            "country": "Russia",
            "greeting": "Привет",
            "code": null
        },
        {
            "country": "the UK",
            "greeting": "Hi",
            "code": null
        }
    ]
}
```

Здесь `country-greeting[]` - существующее значение (`existent_structure`), так как оно уже было раньше; `code` - новое значение, так как его раньше не было. Заметим, что `county-greeting[]` написано без дополнительных объектов `country` и `greeting`, которые, однако, существуют до начала операции добавления нового элемента. Причина тому заключается в том, что программному коду важно не столько знать, КАКИЕ объекты существуют, сколько важно знать, КУДА нужно положить новое значение с учетом СУЩЕСТВУЮЩИХ значений.

По своей программной структуре, функция реализована с помощью рекурсии, где код идет так глубоко, пока не достигнет назначения, написанного в `existent_structure`. Использование рекурсии объясняется тем, что, в связи с наличием списков в JSON, может быть высокая вложенность JSON файла. Поэтому, чтобы ничего не пропустить, код обходит каждый участок JSON структуры рекуррентно.

[Обратно к технической реализации](#техническая-реализация)

- ##### save(queries_list) - реализация

Подробнее о том, что делает данная функция, можно [прочитать выше](#savequeries_list). Технически функция разделена на два раздела: функции `get_structure()` и `fill_structure()`. Рассмотрим их подробнее.

Первая функция получает структуру JSON файла, которую нужно сохранить. Так как на данном этапе не изевстны значения самых глубоких элементов JSON файла, то временно ставятся заглушки со значением `None`.

Например:
```python
get_structure(['A', 'B.C'])

Результат:
{
    "A": None,
    "B": {
        "C": None
    }
}

```

Чтобы так сделать, сначала создается так называемый якорь - далее используем термин `anchor` - создается структура без последнего элемента и якорь добавляется с помощью функции `add` к только что созданной структуре.

Например:
```python
get_srtucture(['A', 'B.C'])

Создание якорей
1) {"A": None}
2) {"C": None}

Создание структуры без последнего элемента
{
    "B": {
         
    }
}

Добавление к созданной структуре якорей
{
    "A": None
    "B": {
        "C": None
    }
}
```

Всё остальное - просто программная реализация функции с учетом, что, во-первых, могут быть списки внутри JSON и, во-вторых, может быть непредвиденное поведение с некоторыми списками из-за особенности с неявным обращением с ссылочным типом данных в Python3. Для более глубокого понимания конкретной технической реализации рекомендуется прочитать программный код.

[Обратно к технической реализации](#техническая-реализация)

- ##### fill_structure() - реализация

Основная задача функции - заполнить созданную функцией `save()` структуру. Для этого она переводит [запрос](#запрос) с языка `json_parser.py` в специальную строку. Строка представляет собой команду, которую нужно исполнить на языке Python3. Команда служит для того, чтобы изменить значение словаря по его индексу и ключам. Исполнение же самой строки проходит с помощью встроенной в Python3 команды `exec()`.

Пример готовой команды для исполнения в `exec()`:
```python
query = "data[0].ID Year" # изначальное значение запроса
order = 'strcuture["data"][0]["ID Year"] = "2019"' # полученная команда для исполнения запроса
exec(order) # исполнение запроса
```

Так как в процессе могут появиться словари с высокой вложенностью, есть специальная переменная `counter`. Она собирает в себе индексы всех существующих уровней вложенности. Затем с помощью `counter` программа создает все строки для исполнения в `exec`. Само значение строки для исполнения в `exec` получается при помощи функции `get_ready_exec_statement`.

Пример работы `counter`:

Есть JSON файл
```json
{
    "country": [
        {
            "name": "Europe",
            "region": [
                {
                    "id": 1,
                    "name": "Krokozia"
                },
                {
                    "id": 2,
                    "name": "Kolechia"
                }
            ]
        }
    ]
}
```

Так как список `country` имеет один элемент, список `region` - два, то `counter` будет изменяться следующим образом:
```python
counter[0][0]
counter[0][1]
```

Если бы `country` имело три элемента, а `region` - два, то `counter` будет изменяться следующим образом:
```python
counter[0][0]
counter[0][1]
counter[1][0]
counter[1][1]
counter[2][0]
counter[2][1]
```

и так далее.

Для изменения индекса в `counter` используется функция `get_next_counter_index`. Для проверки, все ли значения `counter` были исчерпаны, - `was_counter_fully_used`

[Обратно к технической реализации](#техническая-реализация)

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## Взаимодествие фронтенда с бекенд API

Здесь на примере процесса аутентификации представлено объяснение взаимодействия фронтенда и бекенда при помощи API.

Аутентификация и проверка статуса аутентификации пользователя
происходит с помощью [JWT](https://en.wikipedia.org/wiki/JSON_Web_Token)
(JSON Web Token) токенов.

При регистрации у каждого пользователя есть свой уникальный `username`.
Когда осуществляется процес аутентификации пользователя, фронтенд отправляет
http POST запрос в виде JSON файлаю. Например:
```json
{
	"username": "<username>",
	"password": "<password>"
	...
}
```

Если данный `username` существует в базе данных и пароль совпадает, то
бэкенд возвращает следующий JSON файл:
```json
{
	"status": "sucess",
	"token": "<new JWT token>",
	...
}
```
в противном случаее:
```json
{
	"status": "failure"
	"token": ""
}
```
и тогда пользователя должен ввести пароль снова.

Далее если фронтенд хочет получить с бэкенда некоторую информацию, требующую
аутентификации, то он к каждому запросу прикрепляет текущий токен, например:
```json
{
	"token": "<current JWT token>"
	"field1": "<>"
	"field2": "<>"
	...
}
```
и по аналогии: если токен действующий, то сервер возвращает следующий следующий JSON:
```json
{
	"token": "<current JWT token>",
	"field1": "<>",
	"field2": "<>",
	...
}
```
в противном случаее
```json
{
	"status": "failure"
	...
}
```
и тогда пользователя отправляет на страницу аутентификации.

При этом важно помнить, что обратиться к API бекенда можно по пути: `/api/<request>`.

Пример отправки JSON файла http POST запросом:
```js
// JSON запрос для передачи на бекенд
let data = {
	"username": "<username>",
	"password": "<password>",
};

// Ссылка, куда нужно передать данные
let url = "/api/login";

// Настройки для передачи данных. Строки два и три обязательны
let config = {
	"method": "POST",
	"headers": {"Content-Type": "application/json"},
	"body": JSON.stringify(data),
}

fetch(url, config)
	.then(function(response) {
		return response.json();
	})
	.then(function(data) {
		console.log(data) // Выводит данные в консоль
		auth_token = data["token"] // Сохраняет данные в переменную
		// Важно! Из-за ассинхронности переменная auth_token доступна только внутри блока then.
	});
```

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## API reference

- [/api/login](#apilogin)
- [/api/register](#apiregister)
- [/api/auth_test](#apiauth_test)
- [/api/handle-workflow](#apihandle-workflow)
- [/api/get-processors-list](#apiget-processors-list)
- [/api/get-workflow-status](#apiget-workflow-status)

[Обратно к оглавлению](#документация-ritm3-the-tyre)

### /api/login

Проверить действующий токен пользователя.

Форма запроса
```json
{
	"username": "<username>",
	"password": "<password>"
}
```

Успешный ответ (поле с токеном есть только при успешной авторизации)
```json
{
	"status": "success",
	"message": "logged in, token generated",
	"token": "<new JWT token>"
}
```

Все возможные варианты ответов

status  | message
--------|------
success | logged in, token generated
failure | wrong request format
failure | wrong username or password

[Обратно к API ссылкам](#api-reference)

### /api/register

Зарегестрировать нового пользователя.

- `username`: от 4 до 32 символов, английские буквы и цифры
- `password`: от 8 до 16 символов, английские буквы и цифры
(вот тут нужно еще согласовать но пока на беке так)
- `email`: до 40 символов

Форма запроса
```json
{
	"username": "<username>",
	"password": "<password>",
	"email": "<email>"
}
```

Успешный ответ
```json
{
	"status": "success",
	"message": "user created, try to login now",
}
```
Внимание! Высока вероятность вылета и битого JSON (будет исправлено в ближайшее время).

Все возможные варианты ответов

status  | message
--------|------
success | user created, try to login now
failure | wrong request format
failure | username is too small
failure | username is too big
failure | password is too small
failure | password is too big
failure | email is too big
failure | username is not valid
failure | password is not valid
failure | email is not valid
failure | username already exists

[Обратно к API ссылкам](#api-reference)

### /api/auth_test

Проверка действительности токена.

Форма запроса
```json
{
	"token": "<current JWT token>",
}
```

Успешный ответ
```json
{
	"status": "success",
	"message": "authentication confirmed"
}
```

Все возможные варианты ответов

status  | message
--------|------
success | authentication confirmed
failure | wrong request format
failure | token invalid
failure | token expired

[Обратно к API ссылкам](#api-reference)

### /api/handle-workflow

Запрос на выполнение конвейера процессоров.

Форма запроса
```json
{
    "token": "<current JWT token>",
    "workflow": {
        "<processor_1>": ["arg_1", "arg_2", ... ],
        "<processor_2>": ["arg_1", "arg_2", ... ],
        ...
    }
}
```

Успешный ответ
```json
{
    "message":"processors will be executed as specified",
    "status":"success",
    "uuid":"<processors group uuid>"
}
```

Все возможные варианты ответов

status  | message
--------|------
success | processors will be executed as specified
failure | wrong request format
failure | token invalid
failure | there is no such processor - <proc_name>
failure | <proc_name> processor arguments are not list
failure | <proc_name> processor should have <arg_num> arguments

[Обратно к API ссылкам](#api-reference)

### /api/get-processors-list

Получить список доступных процессоров

Форма запроса
```json
{
    "token": "<current JWT token>"
}
```

Успешный ответ
```json
{
    "message":"sent processors list",
    "processors":{
        "dummy_parser":{"id":2,"num_args":0,"type":"parse"},
        "http_request":{"id":4,"num_args":4,"type":"fetch"},
        "is_day_off":{"id":1,"num_args":1,"type":"fetch"},
        "save_to_db":{"id":3,"num_args":2,"type":"save"}
    },
    "status":"success"
}
```

Все возможные варианты ответов

status  | message
--------|------
success | sent processors list
failure | wrong request format
failure | token invalid

[Обратно к API ссылкам](#api-reference)

### /api/get-workflow-status

Получить статус выполнения конкретного конвейера (*группы процессоров*)

Форма запроса
```json
{
    "token": "<current JWT token>",
    "uuid": "<workflow uuid>"
}
```

Успешный ответ
```json
{
    "message":"sent workflow status .json file",
    "status":"success",
    "workflow_status": {
        "dummy_parser":"canceled",
        "http_request":"failed",
        "save_to_db":"canceled"
    }
}
```

Все возможные варианты ответов

status  | message
--------|------
success | sent processors list
failure | wrong request format
failure | token invalid
failure | there is no workflow with provided uuid

[Обратно к API ссылкам](#api-reference)

[Обратно к оглавлению](#документация-ritm3-the-tyre)


## Фронтенд скрипты

- [registration.js](#registrationjs)
- [validator.js](#validatorjs)
- [get-login-data.js](#get-login-datajs)
- [workspace-prototype.js](#workspace-prototypejs)

[Обратно к оглавлению](#документация-ritm3-the-tyre)

### registration.js

Логика связи страницы регистрации `registration.html` с сервером реализована в файле `registration.js`.

Сразу после загрузки страницы происходит проверка наличия токена в локальном хранилище. Если токен обнаружен, то осуществляется запрос к серверу по ссылке `/api/auth_test` для проверки работоспособности токена. Если токен подтвержден, происходит перенаправление пользователя на главную страницу *(добавить ссылку)*. В противном случае скрипт ждёт действий со стороны пользователя.

Скрипт реагирует на нажатие кнопки `id="submit"`, запускается функция `Registration`.

В функции из формы извлекаются поля `"username", "email", "password"` и отправляются в виде JSON на сервер по ссылке `/api/register`. Ответ, полученный также в виде JSON, обрабатывается.

При успешной регистрации пользователь получает оповещение "Новый пользователь создан" и перенаправляется на страницу авторизации. Если регистрация не произошла, пользователь получает оповещение с указанием выявленной ошибки (виды ошибок и сообщения к ним можно узнать в разделе [/api/register/](#apiregister)).

[Обратно фронтенд скриптам](#фронтенд-скрипты)

### validator.js

Процесс валидации пароля при регистрации нового пользователя реализован в файле validator.js.

Параметры, требуемые для валидного пароля:
- использование латиницы\
- хотя бы одна строчная буква *(регулярное выражение для проверки: `/[a-z]/g`)*\
- хотя бы одна заглавная буква *(регулярное выражение для проверки: `/[A-Z]/g`)*\
- хотя бы одна цифра *(регулярное выражение для проверки: `/[0-9]/g`)*\
- длина не менее 8 символов

Когда элемент ввода пароля `id="password"` находится в фокусе, на странице появляется блок с сообщением-подсказкой `id="message"`, который содержит описанные выше параметры и цветом текста сигнализирует о выполнении (зеленый цвет) или невыполнении (красный цвет) требования.

При потере элементом ввода пароля фокуса блок подсказки исчезает.

Во избежание ошибок и опечаток при составлении пароля в форме регистрации присутствует поле повторного ввода пароля `id="password_repeat"`. Когда элемент повторного ввода пароля находится в фокусе рядом появляется сообщение-подсказка `id="alert"`, содержание которого сигнализирует о совпадении (текст "Совпадает" зеленым цветом) или несовпадении (текст "Не совпадает" зеленым цветом) введенных паролей.

При потере элементом повторного ввода пароля фокуса блок подсказки не исчезает.

[Обратно фронтенд скриптам](#фронтенд-скрипты)

### get-login-data.js

Логика связи страницы авторизации `index.html` с сервером реализована в файле `get-login-data.js`.

Сразу после загрузки страницы происходит проверка наличия токена в локальном хранилище. Если токен обнаружен, то осуществляется запрос к серверу по ссылке `/api/auth_test` для проверки работоспособности токена. Если токен подтвержден, происходит перенаправление пользователя на главную страницу *(добавить ссылку)*. В противном случае скрипт ждёт действий со стороны пользователя.

Скрипт реагирует на нажатие кнопки `id="submit"`, запускается функция `Validation`.

В функции из формы извлекаются поля `"username"` и`"password"` и отправляются в виде JSON на сервер по ссылке `/api/login`. Ответ, полученный также в виде JSON, обрабатывается.

При успешной авторизации полученный с сервера токен сохраняется в локальном хранилище, а пользователь перенаправляется на главную страницу *(добавить ссылку)*. Если авторизация не произошла, пользователь получает оповещение о неверно введенных данных (подробнее можно узнать в разделе [/api/login/](#apilogin)).

[Обратно фронтенд скриптам](#фронтенд-скрипты)

### workspace-prototype.js

Скрипт workspace-prototype.js относится к странице workspace-prototype.html, где расположен прототип рабочей области по созданию процессоров и взаимодействию с ними.

Сам скрипт можно разделить на несколько смысловых групп:
- Первая смысловая группа отвечает за изменении состояния открытия окна по созданию процессоров.

- Вторая смысловая группа необходима для открытия и закрытия окна по созданию определенного процессора в зависимости от выбора пользователя.

- Третья смысловая группа позволяет фильтровать запросы, при этом изменяя активное состояние фильтров при нажатии на соответствующие кнопки. (В разработке)

- Четвертая смысловая группа отвечает за отображение реального времени в нижней части шапки.

- Пятая смысловая группа служит для анимации наведения курсора на кнопку с учетом положения этого наведения.

- Шестая смысловая группа необходима для реализации бургер-меню.

[Обратно фронтенд скриптам](#фронтенд-скрипты)

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## Структурная идея верстки

### Именование классов
При проектировании вертски сайта была использовано соглашение по именованию по методолгии БЭМ. Основные правила формирования имен классов:

- Имена записываются латиницей в нижнем регистре.
- Для разделения слов в именах используется дефис (-).
- Имя блока задает пространство имен для его элементов и модификаторов.
- Имя элемента отделяется от имени блока двумя подчеркиваниями (__).
- Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_).
- Значение модификатора отделяется от имени модификатора одним подчеркиванием (_).
- Значение булевых модификаторов в имени не указывается.

### Технические классы

Технические классы - это такие классы, которые предназначены в первую очередь для того, чтобы обозначить разного рода состояния элементов, к примеру, скрыт элемент или находится в потоке, состоянияпри наведении, фокусе, нажатии, является ли элемент активным в данный момент или нет.

Также технические классы преднаначены для создания шаблонов. Например, на странице workspace-prototype.html используется технический класс _container, который предназначен для шаблонизации блока, который ограничен по ширине и имеет стили, которые будут применены в дальнейшем для всех элементов, которые будут контейнерами. То есть данный тенический класс позволяет описать шаблон блока, который потом можно повторно использоваться при проектировании интерфейсов сайта.

Такие классы, как правило, не несует смысловую нагрузку, они предназначены именно для того, чтобы подчекрнуть какое-то состояние или шаблон, который можно использовать в разных местах сайта.

Технические классы должны начинаться с нижнего подчеркивания (_) и описывать состоение элемента или шаблонизацию какого-то элемента.

[Обратно к оглавлению](#документация-ritm3-the-tyre)

## Файловая архитектура frontend
Основная идея используемое архитектуры: одна страница - одна папка.

Структура папки следующая:
page_name  
├── assets  
│   ├── favicon  
│       └── ...  
│   └── img  
│       └── ...  
├── scripts  
│   └── script.js  
├── styles  
│   └── style.css  
└── page_name.html  

Все папки страниц хранятся в папке static.

В папке каждой страницы находятся основной html файл и папки для стилей, скриптов и дополнительных материалов (папки styles, scripts и assets соответственно).
В папке assets могут находится дополнительные материалы, то есть изображения, иконки и прочее.

[Обратно фронтенд скриптам](#фронтенд-скрипты)

[Обратно к оглавлению](#документация-ritm3-the-tyre)


## Тестирование

Для реализации юнит-тестов использовался фреймворк `pytest 7.1.2`. 

Расположение папки с юнит-тестами:
```bash
container-back/src/tests/
```

Чтобы протестировать существующий код, необходимо выполнить следующий набор действий:
1. Запустить контейнер бекенда с именем ritm3-the-tyre-container-back-1
```bash
docker compose --profile backend-api up --build
```
2. Войти в bash панель контейнера бекенда
```bash
docker exec -it ritm3-the-tyre-container-back-1 bash
```
3. Запустить работу юнит-тестов командой
```bash
pytest
```

Внимание! В процессе выполнения тестов могут выходить предупреждения (warnings): это нормально. На данные предупреждения не нужно обращать внимания.

[Обратно к оглавлению](#документация-ritm3-the-tyre)
